defmodule Pixie.Response.Connect do
  defstruct channel: "/meta/connect", client_id: nil, error: nil, advice: nil, ext: nil, id: nil, timestamp: nil
  import Pixie.Utils.Response

  @moduledoc """
  Convert an incoming `Pixie.Message.Connect` into a response.

      Response
      MUST include:  * channel
                     * successful
                     * clientId
      MAY include:   * error
                     * advice
                     * ext
                     * id
                     * timestamp

  This struct contains the following keys:

    - `:channel` always `"/meta/connect"`.
    - `:client_id` the client ID generated by the server during handshake.
    - `:error` an error message to send to the client explaining why the
      request cannot proceed. Optional.
    - `:ext` an arbitrary map of data the server sends for use in extensions
      (usually authentication information, etc). Optional.
    - `:id` a message ID generated by the client. Optional.
    - `:timestamp` the the the response was generated, formatted as ISO8601.
    - `:advice` advice from the server about how to handle timeouts, polling
      intervals, etc. See
      [the Bayeux protocol](http://svn.cometd.org/trunk/bayeux/bayeux.html#toc_32)
      for more information.
  """

  @doc """
  Create a `Pixie.Response.Connect` struct based on some fields from the
  incoming message, and some generated.
  """
  def init %Pixie.Message.Connect{}=message do
    %Pixie.Response.Connect{}
      |> put(message, :id)
      |> put(message, :client_id)
      |> Map.put(:advice, advice)
      |> Map.put(:timestamp, now)
  end

  defp now do
    {:ok, timestamp} = Timex.Date.now |> Timex.DateFormat.format("{ISO}")
    timestamp
  end

  defp advice do
    %{
      reconnect: "retry",
      interval:  0,
      timeout:   Pixie.timeout
    }
  end
end
